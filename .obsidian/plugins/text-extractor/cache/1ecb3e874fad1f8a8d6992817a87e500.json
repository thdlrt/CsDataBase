{"path":"归档课程/数字逻辑与计算机组成/作业答案/第六章作业答案.pdf","text":"考虑以下C语言程序代码： int func1(unsigned word) { return (int) (( word <<24) >> 24); } int func2(unsigned word) { return ( (int) word <<24 ) >> 24; } 假设在一个32位机器上执行这些函数，二进制补码表示int（其实题干应该说清楚 int和unsigned的位数）。说明函数func1和func2的功能，并填表，给出对表中 “异常”数据的说明。 函数func1的功能是把无符号数高24位清零（左移24位再逻辑右移24位），结果一定 是正的带符号整数；而函数func2的功能是把无符号数的高24位都变成和第25位一样， 因为先转换为有符号数，再左移24位（此时左边第一位变为原来的第25位），最后算 术右移，高位补符号，即高24位都变成和原来第25位相同。（下表用16进制表示机器 数） W func1(w) func2(w) 机器数 值 机器数 值 机器数 值 0000007FH 127 0000007FH +127 0000007FH +127 00000080H 128 00000080H +128 FFFFFF80H –128 000000FFH 255 000000FFH +255 FFFFFFFFH –1 00000100H 256 00000000H 0 00000000H 0 3 • 因为逻辑左移和算术左移的结果完全相同，所 以，函数func1和func2中第一步左移24位得到 的结果完全相同，所不同的是右移24位后带来 的结果。 • 上述表中，蓝色数据是一些“异常”结果。当 w=128和255时，第25位正好是1，因此函数 func2执行的结果为一个负数，出现了“异 常”。当w=256时，低8位为00，高24位为非0 值，左移24位后使得有效数字被移出，因而发 生了“溢出”，使得出现了“异常”结果0。 填表，对比无符号数和带符号整数的乘法结果，以及截断操作前、后的结果 模式 x y x×y（截断前） x×y（截断后） 机器数 值 机器数 值 机器数 值 机器数 值 无符号数 110 6 010 2 001100 12 100 4 二进制补码 110 –2 010 +2 111100 –4 100 –4 无符号数 001 1 111 7 000111 7 111 7 二进制补码 001 +1 111 –1 111111 –1 111 –1 无符号数 111 7 111 7 110001 49 001 1 二进制补码 111 –1 111 –1 000001 +1 001 +1 ①对于两个相同的机器数，作为无符号数进行乘法运算和作为带符号整数进行乘法 运算，因为其所用的乘法算法不同，所以，乘积的机器数可能不同。但是，不同的 仅是乘积中的高n位，而低n位完全一样。 ②对于n位乘法运算，若截取2n位乘积的低n位作为最终结果，则都有可能结果溢出， 即n位数字无法表示正确的乘积。带符号整数乘积截断后也可能溢出，例如， 011×011=001001，截断后011×011=001，显然截断后的结果发生了溢出。 ③表中蓝色是截断后发生溢出的情况。溢出判断方法：无符号整数——若乘积中高n 位为全0，则截断后的低n位乘积不发生溢出，否则溢出；带符号整数——若高n位中 的每一位都等于低n位中的第一位，则截断后的低n位乘积不发生溢出，否则溢出。 4 以下是两段C语言代码，函数arith( )是直接用C语言写的，而optarith( )是对arith( ) 函数以某个确定的M和N编译生成的机器代码反编译生成的。根据optarith( )， 可以推断函数arith( ) 中M和N的值各是多少？ #define M #define N int arith (int x, int y) { int result = 0 ; result = x*M + y/N; return result; } int optarith ( int x, int y) { int t = x; x << = 4; x–= t; if ( y < 0 ) y+= 3; y>>=2; return x+y; } 对于x， “x左移4位” 即：x=16x，然后有一条“减法” 指令，即x=16x–x=15x，根据源程序知M=15； 对于y，有一条“y右移2位”指令，即y=y/4，根据源程序 知N=4。 但是，对于带符号整数来说，采用算术右移时，高位补符 号，低位移出。 因此，当符号位为0时，与无符号整数相同，采用移位方 式和直接相除得到的商完全一样。 当符号位为1时，若低位移出的是非全0，则说明不能整除。 这种情况下，移位得到的商与直接相除得到的商不一样， 需要进行校正（在右移前，先将x加上偏移量(2k-1)，然后 再右移k位）。 例如，上述函数optarith中，在执行y>>2之 前加了一条语句“if ( y < 0 ) y+= 3;”，以对y进行校正。 5 • 设A4∼A1和B4∼B1分别是4位加法器的两组输 入，C0为低位来的进位。当加法器分别采用 串行进位和先行进位时，写出4个进位C4∼C1 的逻辑表达式。 串行进位： C1=A1C0+B1C0+A1B1 C2=A2C1+B2C1+A2B2 C3=A3C2+B3C2+A3B3 C4=A4C3+B4C3+A4B4 并行进位： C1=A1B1+(A1+B1)C0 C2=A2B2+(A2+B2)A1B1+(A2+B2)(A1+B1)C0 C3=A3B3+(A3+B3)A2B2+(A3+B3)(A2+B2) A1B1+(A3+B3)(A2+B2)(A1+B1)C0 C4=A4B4+(A4+B4)A3B3+(A4+B4)(A3+B3)A2B2+(A4+B4)(A3+B3)(A2+B2)A1B1 +(A4+B4) (A3+B3)(A2+B2)(A1+B1)C0 6 （1）[x]补=0101B，[y]补=1101B，[–y]补=0011B。 验证真值：x=+5，y=–3，x+y=2，x-y=8 [x+y]补= [x]补+[y]补=0101B +1101B =(1)0010B，因此，x+y=2。 两个不同符号数相加，结果一定不会溢出。。 [x–y]补= [x]补+[–y]补=0101B +0011B = (0)1 000B，因此，x– y=–8。 两个正数相加结果为负，发生了溢出。 验证：8>最大可表示数7，故溢出。 7 （2）[x]原=0101B，[y]原=1101B。将符号和数值部分分开处理。 乘积的符号为0⊕1=1，数值部分采用无符号数乘法算法计算 101×101的乘积。共循环3次，最终得到一个8位无符号数表示的 乘积1 0011001B。（自动补齐8位，最高位数值位直接添加0） 符号位为1，因此，［x×y］原=1 0011001，因此，x×y=–25。 若结果取4位原码1 001，则因为乘积数值部分高3位为011，是一个非0数，所以， 结果溢出。验证：4位原码的表示范围为-7～+7，显然乘积–25不在其范围内， 结果应该溢出。 （3）[x]补=0 101B，[–x]补=1011B， [y]补=1101B。 采用MBA（基4布斯）算法时，符号和数值部分一起参加运算，在乘数后 面添0，初始部分积为0，并在部分积前加一位补充符号位0（C那一 列）。每次循环先根据乘积寄存器中最低3位决定执行+X、+2X、–X、 –2X、还是+0操作，然后将得到的新的部分积和乘数寄存器中的部分 乘数一起算术右移两位。–X和–2X分别采用+[–x]补和+2[–x]补的方式进 行。共循环两次。最终得到一个8位补码表示的乘积1111 0001 B。 ［x×y］补=1111 0001，因此，x×y= –15。 如果仅保留低4位，则溢出 （4）[x]原=0101B，[y]原=1101B。将符号和数 值部分分开处理。 将符号和数值部分分开处理。商的符号为0⊕1=1，数值部分 采用无符号数除法算法计算101B和101B的商和余数。 最高位需添加符号位， 整数除法，所以被除数高位补0 为了实现补码加减，余商都补足4位，但其实商只有最后三位是有意义的。 第一个绿色的0代表不溢出。第一个红色的0相当于符号位，而且肯定是0 R: 0000 0101 R = R–D 1011 1011 0101 sl R, 0 R: 0110 1010 R = R+D 0101 1011 1010 sl R, 0 R: 0111 0100 R = R+D 0101 1100 0100 sl R, 0 R: 1000 1000 R = R+D 0101 1101 1000 sl R, 0 R: 1011 0000 R = R+D 0101 0000 0001 验证：0101 / 0101 = 1 余 0 不恢复余数法、加减交替法 负，０，加 正，１，减 –D = 1011 第1位商为绿色0，在最后 （第5次）被左移出去，并 加上最后一位商 且最后一次上商1，余数无 需恢复就是正确的。 第1次上商为“试商”， 仅仅表示不溢出 R：被除数（中间余数）; D：除数 可以省略第一步，也就是第一个绿色的0直接加入， 并把初始的余商0000 0101一起左移一次变成0000 1010 R: 0000 1010 R = R–D 1011 1011 0101 sl R, 0 R: 0110 1010 R = R+D 0101 1011 1010 sl R, 0 R: 0111 0100 R = R+D 0101 1100 0100 sl R, 0 R: 1000 1000 R = R+D 0101 1101 1000 sl R, 0 R: 1011 0000 R = R+D 0101 0000 0001 验证：0101 / 0101 = 1 余 0 不恢复余数法、加减交替法 负，０，加 正，１，减 –D = 1011 第1位商为绿色0，在最后 （第4次）被左移出去，并 加上最后一位商 且最后一次上商1，余数无 需恢复就是正确的。 第1次直接上商0并左移， 因为肯定不溢出 R：被除数（中间余数）; D：除数 还可以这样做：为了实现补码加减，余数补足4位，商仅用3位 最后获得三位商均为数值位。第一个绿色的0代表不溢出。 R: 0000 101 R = R–D 1011 1011 101 sl R, 0 R: 0111 010 R = R+D 0101 1100 010 sl R, 0 R: 1000 100 R = R+D 0101 1101 100 sl R, 0 R: 1011 000 R = R+D 0101 0000 000 sl R, 0 R: 0000 001 验证：0101 / 0101 = 1 余 0 不恢复余数法、加减交替法 负，０，加 正，１，减 –D = 1011 第1位商为绿色0，在最后 （第4次）被左移出去，并 加上最后一位商 且最后一次上商1，余数无 需恢复就是正确的。 第1次上商为“试商”， 仅仅表示不溢出 R：被除数（中间余数）; D：除数 （5）[x]补=0101B，[y]补=1101B。 +y 即为+[1101]， -y 即为+[0011] 补码不恢复余数除法过程描述如下：初始中间余数（被除数） 高位补0后为0000 0101，整个循环内执行的要点是“同、 1、减；异、0、加”。共循环4次，得到商1110和余数 0010。最终根据情况需要对商和余数进行修正。（Y符号 为1，每次判断中间余数和1的同异，同则商为1，然后左 移，然后减法。 异号则商为0，然后左移，然后加法。） 商的修正：最后一次Q寄存器左 移一位，将最高位qn移出，最低 位置商q0=0。若被除数与除数同 号， Q中就是真正的商；否则， 将Q中商的末位加1。故商为 1110+1=1111B。 余数的修正：若余数符号同被除 数符号，则不需修正；否则，按 下列规则进行修正：当被除数和 除数符号相同时，最后余数加除 数；否则，最后余数减除数。故 余数为0010B。 商的为1111（-1），余数为0010 （2）。验证：“除数×商+余数= 被除数”进行验证，得(-3)×(-1) +2 =5。","libVersion":"0.2.4","langs":""}